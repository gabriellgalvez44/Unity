<!DOCTYPE html>
<html lang=en>
<head>
<title>Unity Scripts - PlayerMovement.cs</title>
</head>
<body>
<section>
<button onclick="window.location.href='library.html'"><- Back...</button>
</section>
<section>
<left>
<h1>PlayerMovement.cs</h1>
<button onclick="window.open('https://drive.google.com/uc?export=download&id=1d8swOtqjk1MAse-dpjCyam07MxvZEDX1')">Download</button>
<h1>Version 15:</h1>
This script is used to make an object considered the player and add keybinding controls for moving, advanced movement, and etc...
<h1>Method names:</h1>
(There are none)
<h1>IMPORTANT:</h1>
When using 2D mode, your project must still be a 3D project and you have to use 3D objects, just make your camera orthographic and follow a bit differently!<br><br>
In addition, this script requires the usage of the <1 href=GamControl.html>GameControl.cs</1> script to work
</left>
<right>
<textarea readonly>using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMovement : MonoBehaviour
{
    [Header("Camera Identifier")]
    public Transform cameraTransform;
    [Header("General settings")]
    public bool gravity = true;
    public bool stopExternalAccelleration = false;
    public bool rotationConstraints = true;
    [Header("2D game settings")]
    public bool isGame2D = false;
    public bool stayInCameraBounds = false;
    public bool allowVerticalMovement = true;
    [Header("Permission")]
    public bool allowJump = true;
    public bool allowSprint = true;
    public bool allowWallRunning = false;
    public bool allowDashing = false;
    private float originalSprintSpeed = 0f;
    private bool stored3 = false;
    [Header("Stamina")]
    public GameObject statObject;
    public string staminaStatName;
    public float staminaRechargeDelay = 2.5f;
    public int staminaRechargePerSecond = 20;
    private int stamina;
    private Stat staminaStatRef;
    private int maxStamina;
    private Coroutine rechargeDelayCoroutine;
    private Coroutine rechargeCoroutine;
    [Header("Walking")]
    public float speed = 4.0f;
    public MonoBehaviour walkTargetComponent;
    public string walkMethodName;
    [Header("Sprinting")]
    public float sprintingSpeed = 7.0f;
    public MonoBehaviour sprintTargetComponent;
    public string sprintMethodName;
    public int sprintStaminaUsagePerSecond = 10;
    private Coroutine sprintDrainCoroutine;
    [Header("Wall Running")]
    public LayerMask wallLayers;
    public float wallRunCameraTilt = 15f;
    public float tiltSpeed = 5f;
    [Header("Dashing")]
    public int dashStaminaUsage = 30;
    public GameControl GameControllerObject;
    public MonoBehaviour dashStartTargetComponent;
    public string dashStartMethodName;
    public float dashDistance = 5f;
    public MonoBehaviour dashedTargetComponent;
    public string dashedMethodName;
    public LayerMask passthroughLayer;
    public bool infiniteAirDashes = false;
    [Header("Jumping")]
    public int jumpStaminaUsage = 5;
    public float jumpAcceleration = 5f;
    public MonoBehaviour jumpTargetComponent;
    public string jumpMethodName;
    public float maxAirJumps = 1f;
    public MonoBehaviour airJumpTargetComponent;
    public string airJumpMethodName;
    private Rigidbody rb;
    private bool isWallRunning = false;
    private Vector3 wallNormal;
    private Coroutine tiltCoroutine;
    private bool isOnRightSide;
    private Vector3 wallRunStartPosition;
    private int remainingAirJumps;
    private Vector3 originalPosition;
    [Header("Player event interactions")]
    [Header("On landing behavior")]
    public MonoBehaviour landTargetComponent;
    public string landMethodName;
    [Header("On still behavior")]
    public MonoBehaviour stillTargetComponent;
    public string stillMethodName;
    [Header("On wallRun enter behavior")]
    public MonoBehaviour wallRunEnterTargetComponent;
    public string wallRunEnterMethodName;
    [Header("On wallRun exit behavior")]
    public MonoBehaviour wallRunExitTargetComponent;
    public string wallRunExitMethodName;
    private bool stored = false;
    private bool stored2 = false;
    private bool grounded = false;
    private void Awake()
    {
        rb = gameObject.AddComponent<Rigidbody>();
        if (rotationConstraints)
        {
            rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationY | RigidbodyConstraints.FreezeRotationZ;
        }
        rb.useGravity = gravity;
    }
    private void Start()
    {
        originalSprintSpeed = sprintingSpeed;
        originalPosition = transform.position;
        ResetAirJumps();
        if (statObject == null)
        {
            Debug.LogWarning("StatObject is not assigned.");
            return;
        }
        StatCreator statCreator = statObject.GetComponent<StatCreator>();
        if (statCreator == null)
        {
            Debug.LogWarning("No StatCreator component found on statObject.");
            return;
        }
        foreach (var stat in statCreator.stats)
        {
            if (stat.statName == staminaStatName && stat.statType == StatType.Int)
            {
                staminaStatRef = stat;
                stamina = stat.intValue;
                maxStamina = stat.noMaxLimit ? int.MaxValue : Mathf.FloorToInt(stat.maxLimit);
                break;
            }
        }
    }
    private void ResetAirJumps()
    {
        remainingAirJumps = (int)maxAirJumps;
    }
    private void Update()
    {
        if (allowSprint)
        {
            if (sprintingSpeed != originalSprintSpeed && !stored3)
            {
                originalSprintSpeed = sprintingSpeed;
            }
            if (stored3)
            {
                sprintingSpeed = originalSprintSpeed;
                stored3 = false;
            }
        }
        else
        {
            sprintingSpeed = speed;
            stored3 = true;
        }
        if (gravity && allowJump)
        {
            HandleJump();
        }
        HandleDash();
        if (staminaStatRef == null)
        {
            stamina = 100;
            maxStamina = 100;
        }
        else
        {
            stamina = staminaStatRef.intValue;
        }
    }
    void FixedUpdate()
    {
        if (stopExternalAccelleration)
        {
            rb.linearVelocity = Vector3.zero;
            rb.angularVelocity = Vector3.zero;
        }
        if (!gravity)
            {
                if (Input.GetKey(KeyCode.Space) && !Input.GetKey(KeyCode.LeftControl) && !Input.GetKey(KeyCode.RightControl))
                {
                    Vector3 currentVelocity = rb.linearVelocity;
                    rb.linearVelocity = new Vector3(currentVelocity.x, jumpAcceleration, currentVelocity.z);
                }
                else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
                {
                    Vector3 currentVelocity = rb.linearVelocity;
                    rb.linearVelocity = new Vector3(currentVelocity.x, -jumpAcceleration, currentVelocity.z);
                }
                else
                {
                    Vector3 currentVelocity = rb.linearVelocity;
                    rb.linearVelocity = new Vector3(currentVelocity.x, 0f, currentVelocity.z);
                }
            }
        HandleMovement();
        if (!IsGrounded())
        {
            grounded = false;
        }
    }
    private void HandleDash()
    {
        if (stamina >= dashStaminaUsage || staminaStatRef == null)
        {
            if (allowDashing)
            {
                if (Input.GetKeyDown(KeyCode.Q))
                {
                    if (GameControllerObject != null)
                    {
                        GameControllerObject.timeSpeed = 0.1f;
                        activateDashStartAction();
                    }
                }
                if (Input.GetKeyUp(KeyCode.Q))
                {
                    if (GameControllerObject != null)
                    {
                        GameControllerObject.timeSpeed = 1f;
                        activateDashedAction();
                    }
                    Vector3 dashDirection = cameraTransform.forward;
                    dashDirection.y = 0;
                    dashDirection.Normalize();
                    if (grounded || !infiniteAirDashes)
                    {
                        StartCoroutine(DashRoutine(dashDirection * dashDistance));
                    }
                }
            }
        }
    }
    private IEnumerator DashRoutine(Vector3 dashOffset)
    {
        Vector3 start = transform.position;
        Vector3 end = start + dashOffset;
        float t = 0f;
        RaycastHit hit;
        while (t < 0.05f)
        {
            t += Time.unscaledDeltaTime;
            Vector3 newPos = Vector3.Lerp(start, end, t / 0.05f);
            if (Physics.Raycast(start, newPos - start, out hit, (newPos - start).magnitude))
            {
                if (((1 << hit.collider.gameObject.layer) & passthroughLayer) == 0)
                {
                    newPos = hit.point;
                    break;
                }
            }
            transform.position = newPos;
            yield return null;
        }
        if (t >= 0.05f)
        {
            transform.position = end;
        }
    }
    public void decStamin(int amu)
    {
        if (staminaStatRef == null) return;
        staminaStatRef.intValue = Mathf.Max(0, staminaStatRef.intValue - amu);
        stamina = staminaStatRef.intValue;
        if (rechargeCoroutine != null)
        {
            StopCoroutine(rechargeCoroutine);
            rechargeCoroutine = null;
        }
        if (rechargeDelayCoroutine != null)
            StopCoroutine(rechargeDelayCoroutine);

        rechargeDelayCoroutine = StartCoroutine(StartRechargeAfterDelay());
    }
    private IEnumerator StartRechargeAfterDelay()
    {
        yield return new WaitForSeconds(staminaRechargeDelay);
        rechargeCoroutine = StartCoroutine(RechargeStamina());
    }
    private IEnumerator RechargeStamina()
    {
        while (staminaStatRef != null && staminaStatRef.intValue < maxStamina)
        {
            staminaStatRef.intValue++;
            stamina = staminaStatRef.intValue;
            float delay = 1f / staminaRechargePerSecond;
            yield return new WaitForSeconds(delay);
            if (staminaStatRef.intValue >= maxStamina)
            {
                staminaStatRef.intValue = maxStamina;
                stamina = staminaStatRef.intValue;
                break;
            }
        }
        rechargeCoroutine = null;
    }
    private void activateWallRunStopAction()
    {
        decStamin(jumpStaminaUsage);
        if (wallRunExitTargetComponent != null && !string.IsNullOrEmpty(wallRunExitMethodName))
        {
            wallRunExitTargetComponent.Invoke(wallRunExitMethodName, 0f);
        }
    }
    private void activateJumpAction()
    {
        decStamin(jumpStaminaUsage);
        if (jumpTargetComponent != null && !string.IsNullOrEmpty(jumpMethodName))
        {
            jumpTargetComponent.Invoke(jumpMethodName, 0f);
        }
    }
    private void activateAirJumpAction()
    {
        decStamin(jumpStaminaUsage);
        if (airJumpTargetComponent != null && !string.IsNullOrEmpty(airJumpMethodName))
        {
            airJumpTargetComponent.Invoke(airJumpMethodName, 0f);
        }
    }
    private void activateSprintAction()
    {
        if (sprintTargetComponent != null && !string.IsNullOrEmpty(sprintMethodName))
        {
            sprintTargetComponent.Invoke(sprintMethodName, 0f);
        }
        if (sprintDrainCoroutine == null)
            sprintDrainCoroutine = StartCoroutine(DrainStaminaWhileSprinting());
    }
    private void activateStillAction()
    {
        if (stillTargetComponent != null && !string.IsNullOrEmpty(stillMethodName))
        {
            stillTargetComponent.Invoke(stillMethodName, 0f);
        }
        StopSprintDrain();
    }
    private void activateWalkAction()
    {
        if (walkTargetComponent != null && !string.IsNullOrEmpty(walkMethodName))
        {
            walkTargetComponent.Invoke(walkMethodName, 0f);
        }
        StopSprintDrain();
    }
    private void activateDashStartAction()
    {
        if (dashStartTargetComponent != null && !string.IsNullOrEmpty(dashStartMethodName))
        {
            dashStartTargetComponent.Invoke(dashStartMethodName, 0f);
        }
    }
    private void activateDashedAction()
    {
        if (dashedTargetComponent != null && !string.IsNullOrEmpty(dashedMethodName))
        {
            decStamin(dashStaminaUsage);
            dashedTargetComponent.Invoke(dashedMethodName, 0f);
        }
    }
    private void HandleMovement()
    {
        if (!isWallRunning)
        {
            float moveHorizontal = Input.GetAxis("Horizontal");
            float moveVertical = Input.GetAxis("Vertical");
            if (isGame2D && !allowVerticalMovement)
            {
                moveVertical = 0;
            }
            float currentSpeed = (Input.GetKey(KeyCode.LeftShift) && stamina > 0) ? sprintingSpeed : speed;

            if (isGame2D)
            {
                if (stayInCameraBounds)
                {
                    Camera camera = cameraTransform.GetComponent<Camera>();
                    float cameraHeight = camera.orthographicSize;
                    float cameraWidth = cameraHeight * camera.aspect;
                    Vector3 playerPos = transform.position;
                    float leftLimit = cameraTransform.position.x - cameraWidth;
                    float rightLimit = cameraTransform.position.x + cameraWidth;
                    float topLimit = cameraTransform.position.y + cameraHeight;
                    float bottomLimit = cameraTransform.position.y - cameraHeight;
                    float clampedX = Mathf.Clamp(playerPos.x, leftLimit, rightLimit);
                    float clampedY = Mathf.Clamp(playerPos.y, bottomLimit, topLimit);
                    transform.position = new Vector3(clampedX, clampedY, playerPos.z);
                }
                if (!gravity)
                {
                    rb.linearVelocity = new Vector3(moveHorizontal * currentSpeed, moveVertical * currentSpeed, 0);
                }
                else
                {
                    rb.linearVelocity = new Vector3(moveHorizontal * currentSpeed, rb.linearVelocity.y, 0);
                }
            }
            else
            {
                Vector3 forward = cameraTransform.forward;
                Vector3 right = cameraTransform.right;
                forward.y = 0;
                right.y = 0;
                forward.Normalize();
                right.Normalize();
                Vector3 movement = (right * moveHorizontal + forward * moveVertical).normalized;
                transform.position += movement * currentSpeed * Time.deltaTime;
            }
        }
        else
        {
            if (Input.GetKey(KeyCode.W))
            {
                float currentSpeed = Input.GetKey(KeyCode.LeftShift) ? sprintingSpeed : speed;
                if (isGame2D)
                {
                    if (!gravity)
                    {
                        rb.linearVelocity = new Vector3(0, currentSpeed, 0);
                    }
                }
                else
                {
                    Vector3 forward = cameraTransform.forward;
                    forward.y = 0;
                    forward.Normalize();
                    Vector3 wallDirection = Vector3.Cross(wallNormal, Vector3.up).normalized;
                    float dot = Vector3.Dot(forward, wallDirection);
                    if (dot > 0)
                    {
                        transform.position += wallDirection * currentSpeed * Time.deltaTime;
                    }
                    else if (dot < 0)
                    {
                        transform.position -= wallDirection * currentSpeed * Time.deltaTime;
                    }
                }
            }
            else
            {
                rb.linearVelocity = Vector3.zero;
                rb.angularVelocity = Vector3.zero;
            }
        }
        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.LeftShift))
        {
            int currentStamina = staminaStatRef != null ? staminaStatRef.intValue : stamina;
            if (Input.GetKey(KeyCode.W) && (!Input.GetKey(KeyCode.LeftShift) || currentStamina <= 0))
            {
                if (!stored2)
                {
                    stored = true;
                    stored2 = true;
                    activateWalkAction();
                }
            }
            else if (Input.GetKey(KeyCode.W) && Input.GetKey(KeyCode.LeftShift) && currentStamina > 0)
            {
                if (stored2 && stored)
                {
                    stored = false;
                    stored2 = false;
                }
                if (!stored)
                {
                    stored = true;
                    if (allowSprint)
                    {
                        activateSprintAction();
                    }
                }
            }
            else if (!Input.GetKey(KeyCode.W) && stored)
            {
                stored = false;
                activateStillAction();
            }
        }
        else
        {
            if (stored || stored2)
            {
                stored = false;
                stored2 = false;
                activateStillAction();
            }
        }
    }
    private float originalTilt;
    private float currentTargetTilt;
    private IEnumerator SmoothCameraTilt(float targetTilt)
    {
        float currentTilt = cameraTransform.localEulerAngles.z;
        if (currentTilt > 180) currentTilt -= 360;
        while (Mathf.Abs(currentTilt - targetTilt) > 0.1f)
        {
            currentTilt = Mathf.Lerp(currentTilt, targetTilt, tiltSpeed * Time.deltaTime);
            cameraTransform.localRotation = Quaternion.Euler(cameraTransform.localEulerAngles.x, cameraTransform.localEulerAngles.y, currentTilt);
            yield return null;
        }
        cameraTransform.localRotation = Quaternion.Euler(cameraTransform.localEulerAngles.x, cameraTransform.localEulerAngles.y, targetTilt);
        while (isWallRunning)
        {
            cameraTransform.localRotation = Quaternion.Euler(cameraTransform.localEulerAngles.x, cameraTransform.localEulerAngles.y, targetTilt);
            yield return null;
        }
    }
    private void StartWallRunning(Vector3 wallNormal)
    {
        if (wallRunEnterTargetComponent != null && !string.IsNullOrEmpty(wallRunEnterMethodName))
        {
            wallRunEnterTargetComponent.Invoke(wallRunEnterMethodName, 0f);
        }
        isWallRunning = true;
        this.wallNormal = wallNormal;
        rb.useGravity = false;
        wallRunStartPosition = transform.position;
        rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
        Vector3 wallDirection = Vector3.Cross(wallNormal, Vector3.up);
        isOnRightSide = Vector3.Dot(cameraTransform.right, wallNormal) < 0;
        originalTilt = cameraTransform.localEulerAngles.z;
        currentTargetTilt = isOnRightSide ? wallRunCameraTilt : -wallRunCameraTilt;
        if (tiltCoroutine != null)
        {
            StopCoroutine(tiltCoroutine);
        }
        tiltCoroutine = StartCoroutine(SmoothCameraTilt(currentTargetTilt));
    }
    private void StopWallRunning()
    {
        isWallRunning = false;
        rb.useGravity = true;
        if (tiltCoroutine != null)
        {
            StopCoroutine(tiltCoroutine);
        }
        tiltCoroutine = StartCoroutine(SmoothCameraTilt(originalTilt));
        rb.angularVelocity = Vector3.zero;
    }
    private void HandleJump()
    {
        if (!allowJump) return;
        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (stamina < jumpStaminaUsage && staminaStatRef != null) return;
            if (isWallRunning)
            {
                rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
                Vector3 jumpDirection = (Vector3.up + wallNormal).normalized;
                rb.AddForce(jumpDirection * jumpAcceleration, ForceMode.VelocityChange);
                StopWallRunning();
                activateWallRunStopAction();
            }
            else if (IsGrounded())
            {
                rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
                rb.AddForce(Vector3.up * jumpAcceleration, ForceMode.VelocityChange);
                ResetAirJumps();
                activateJumpAction();
            }
            else if (remainingAirJumps > 0)
            {
                rb.linearVelocity = new Vector3(rb.linearVelocity.x, 0f, rb.linearVelocity.z);
                rb.AddForce(Vector3.up * jumpAcceleration, ForceMode.VelocityChange);
                remainingAirJumps--;
                activateAirJumpAction();
            }
        }
    }
    private void OnCollisionEnter(Collision collision)
    {
        if (allowWallRunning && IsWallRunnable(collision))
        {
            StartWallRunning(collision.contacts[0].normal);
        }
        else if (IsGrounded(collision))
        {
            ResetAirJumps();
            if (!grounded)
            {
                grounded = true;
                if (landTargetComponent != null && !string.IsNullOrEmpty(landMethodName))
                {
                    landTargetComponent.Invoke(landMethodName, 0f);
                }
            }
        }
    }
    private void OnCollisionExit(Collision collision)
    {
        if (isWallRunning && IsWallRunnable(collision))
        {
            StopWallRunning();
        }
    }
    private bool IsWallRunnable(Collision collision)
    {
        return (wallLayers.value & (1 << collision.gameObject.layer)) > 0;
    }
    private bool IsGrounded()
    {
        return Physics.Raycast(transform.position, Vector3.down, 1.1f);
    }
    private bool IsGrounded(Collision collision)
    {
        foreach (ContactPoint contact in collision.contacts)
        {
            if (Vector3.Dot(contact.normal, Vector3.up) > 0.9f)
            {
                return true;
            }
        }
        return false;
    }
    private void StopSprintDrain()
    {
        if (sprintDrainCoroutine != null)
        {
            StopCoroutine(sprintDrainCoroutine);
            sprintDrainCoroutine = null;
        }
    }
    private IEnumerator DrainStaminaWhileSprinting()
    {
        while (true)
        {
            float delay = 1f / sprintStaminaUsagePerSecond;
            decStamin(1);
            if (stamina <= 0)
            {
                StopSprintDrain();
                yield break;
            }
            yield return new WaitForSeconds(delay);
        }
    }
}</textarea>
</right>
</section>
</body>
<script src=https://gabriellgalvez44.github.io/Data/shorten.js></script>
<link rel=stylesheet href=../script.css>
</html>
